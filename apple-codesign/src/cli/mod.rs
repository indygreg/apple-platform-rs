// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

pub mod certificate_source;
pub mod debug_commands;

use {
    crate::{
        certificate::{
            create_self_signed_code_signing_certificate, AppleCertificate, CertificateProfile,
        },
        cli::certificate_source::CertificateSource,
        code_directory::{CodeDirectoryBlob, CodeSignatureFlags},
        code_requirement::CodeRequirements,
        cryptography::DigestType,
        embedded_signature::{Blob, CodeSigningSlot, RequirementSetBlob},
        error::AppleCodesignError,
        macho::MachFile,
        reader::SignatureReader,
        remote_signing::{
            session_negotiation::{create_session_joiner, SessionJoinState},
            RemoteSignError, UnjoinedSigningClient,
        },
        signing::UnifiedSigner,
        signing_settings::{SettingsScope, SigningSettings},
    },
    base64::{engine::general_purpose::STANDARD as STANDARD_ENGINE, Engine},
    clap::{ArgAction, Args, Parser, Subcommand},
    cryptographic_message_syntax::SignedData,
    difference::{Changeset, Difference},
    log::{error, warn, LevelFilter},
    serde::Deserialize,
    spki::EncodePublicKey,
    std::{
        collections::BTreeMap,
        io::Write,
        path::{Path, PathBuf},
        str::FromStr,
    },
    x509_certificate::{CapturedX509Certificate, EcdsaCurve, KeyAlgorithm, X509CertificateBuilder},
};

#[cfg(feature = "notarize")]
use crate::notarization::Notarizer;

#[cfg(feature = "yubikey")]
use {
    crate::yubikey::YubiKey,
    yubikey::{PinPolicy, TouchPolicy},
};

#[cfg(target_os = "macos")]
use crate::macos::{
    keychain_find_code_signing_certificates, macos_keychain_find_certificate_chain, KeychainDomain,
};

pub const KEYCHAIN_DOMAINS: [&str; 4] = ["user", "system", "common", "dynamic"];

const GENERATE_SELF_SIGNED_CERTIFICATE_ABOUT: &str = "\
Generate a self-signed certificate that can be used for code signing.

This command will generate a new key pair using the algorithm of choice
then create an X.509 certificate wrapper for it that is signed with the
just-generated private key. The created X.509 certificate has extensions
that mark it as appropriate for code signing.

Certificates generated with this command can be useful for local testing.
However, because it is a self-signed certificate and isn't signed by a
trusted certificate authority, Apple operating systems may refuse to
load binaries signed with it.

By default the command prints 2 PEM encoded blocks. One block is for the
X.509 public certificate. The other is for the PKCS#8 private key (which
can include the public key).

The `--pem-filename` argument can be specified to write the generated
certificate pair to a pair of files. The destination files will have
`.crt` and `.key` appended to the value provided.

When the certificate is written to a file, it isn't printed to stdout.
";

const PARSE_CODE_SIGNING_REQUIREMENT_ABOUT: &str = "\
Parse code signing requirement data into human readable text.

This command can be used to parse binary code signing requirement data and
print it in various formats.

The source input format is the binary code requirement serialization. This
is the format generated by Apple's `csreq` tool via `csreq -b`. The binary
data begins with header magic `0xfade0c00`.

The default output format is the Code Signing Requirement Language. But the
output format can be changed via the --format argument.

Our Code Signing Requirement Language output may differ from Apple's. For
example, `and` and `or` expressions always have their sub-expressions surrounded
by parentheses (e.g. `(a) and (b)` instead of `a and b`) and strings are always
quoted. The differences, however, should not matter to the parser or result
in a different binary serialization.
";

const SIGN_ABOUT: &str = "\
Adds code signatures to a signable entity.

This command can sign the following entities:

* A single Mach-O binary (specified by its file path)
* A bundle (specified by its directory path)
* A DMG disk image (specified by its path)
* A XAR archive (commonly a .pkg installer file)

If the input is Mach-O binary, it can be a single or multiple/fat/universal
Mach-O binary. If a fat binary is given, each Mach-O within that binary will
be signed.

If the input is a bundle, the bundle will be recursively signed. If the
bundle contains nested bundles or Mach-O binaries, those will be signed
automatically.

# Settings Scope

The following signing settings are global and apply to all signed entities:

* --pem-source
* --team-name
* --timestamp-url

The following signing settings can be scoped so they only apply to certain
entities:

* --digest
* --binary-identifier
* --code-requirements-files
* --code-resources-file
* --code-signature-flags
* --entitlements-xml-file
* --info-plist-file

Scoped settings take the form <value> or <scope>:<value>. If the 2nd form
is used, the string before the first colon is parsed as a \"scoping string\".
It can have the following values:

* `main` - Applies to the main entity being signed and all nested entities.
* `@<integer>` - e.g. `@0`. Applies to a Mach-O within a fat binary at the
  specified index. 0 means the first Mach-O in a fat binary.
* `@[cpu_type=<int>` - e.g. `@[cpu_type=7]`. Applies to a Mach-O within a fat
  binary targeting a numbered CPU architecture (using numeric constants
  as defined by Mach-O).
* `@[cpu_type=<string>` - e.g. `@[cpu_type=x86_64]`. Applies to a Mach-O within
  a fat binary targeting a CPU architecture identified by a string. See below
  for the list of recognized values.
* `<string>` - e.g. `path/to/file`. Applies to content at a given path. This
  should be the bundle-relative path to a Mach-O binary, a nested bundle, or
  a Mach-O binary within a nested bundle. If a nested bundle is referenced,
  settings apply to everything within that bundle.
* `<string>@<int>` - e.g. `path/to/file@0`. Applies to a Mach-O within a
  fat binary at the given path. If the path is to a bundle, the setting applies
  to all Mach-O binaries in that bundle.
* `<string>@[cpu_type=<int|string>]` e.g. `Contents/MacOS/binary@[cpu_type=7]`
  or `Contents/MacOS/binary@[cpu_type=arm64]`. Applies to a Mach-O within a
  fat binary targeting a CPU architecture identified by its integer constant
  or string name. If the path is to a bundle, the setting applies to all
  Mach-O binaries in that bundle.

The following named CPU architectures are recognized:

* arm
* arm64
* arm64_32
* x86_64

Signing will traverse into nested entities:

* A fat Mach-O binary will traverse into the multiple Mach-O binaries within.
* A bundle will traverse into nested bundles.
* A bundle will traverse non-code \"resource\" files and sign their digests.
* A bundle will traverse non-main Mach-O binaries and sign them, adding their
  metadata to the signed resources file.

# Bundle Signing Overrides Settings

When signing bundles, some settings specified on the command line will be
ignored. This is to ensure that the produced signing data is correct. The
settings ignored include (but may not be limited to):

* --binary-identifier for the main executable. The `CFBundleIdentifier` value
  from the bundle's `Info.plist` will be used instead.
* --code-resources-path. The code resources data will be computed automatically
  as part of signing the bundle.
* --info-plist-path. The `Info.plist` from the bundle will be used instead.
* --digest

# Designated Code Requirements

When using Apple issued code signing certificates, we will attempt to apply
an appropriate designated requirement automatically during signing which
matches the behavior of what `codesign` would do. We do not yet support all
signing certificates and signing targets for this, however. So you may
need to provide your own requirements.

Designated code requirements can be specified via --code-requirements-path.

This file MUST contain a binary/compiled code requirements expression. We do
not (yet) support parsing the human-friendly code requirements DSL. A
binary/compiled file can be produced via Apple's `csreq` tool. e.g.
`csreq -r '=<expression>' -b /output/path`. If code requirements data is
specified, it will be parsed and displayed as part of signing to ensure it
is well-formed.

# Code Signing Key Pair

By default, the embedded code signature will only contain digests of the
binary and other important entities (such as entitlements and resources).
This is often referred to as \"ad-hoc\" signing.

To use a code signing key/certificate to derive a cryptographic signature,
you must specify a source certificate to use. This can be done in the following
ways:

* The --p12-file denotes the location to a PFX formatted file. These are
  often .pfx or .p12 files. A password is required to open these files.
  Specify one via --p12-password or --p12-password-file or enter a password
  when prompted.
* The --pem-file argument defines paths to files containing PEM encoded
  certificate/key data. (e.g. files with \"===== BEGIN CERTIFICATE =====\").
* The --certificate-der-file argument defines paths to files containing DER
  encoded certificate/key data.
* The --keychain-domain and --keychain-fingerprint arguments can be used to
  load code signing certificates from macOS keychains. These arguments are
  ignored on non-macOS platforms.
* The --smartcard-slot argument defines the name of a slot in a connected
  smartcard device to read from. `9c` is common.
* Arguments beginning with --remote activate *remote signing mode* and can
  be used to delegate cryptographic signing operations to a separate machine.
  It is strongly advised to read the user documentation on remote signing
  mode at https://gregoryszorc.com/docs/apple-codesign/main/.

If you export a code signing certificate from the macOS keychain via the
`Keychain Access` application as a .p12 file, we should be able to read these
files via --p12-file.

When using --pem-file, certificates and public keys are parsed from
`BEGIN CERTIFICATE` and `BEGIN PRIVATE KEY` sections in the files.

The way certificate discovery works is that --p12-file is read followed by
all values to --pem-file. The seen signing keys and certificates are
collected. After collection, there must be 0 or 1 signing keys present, or
an error occurs. The first encountered public certificate is assigned
to be paired with the signing key. All remaining certificates are assumed
to constitute the CA issuing chain and will be added to the signature
data to facilitate validation.

If you are using an Apple-issued code signing certificate, we detect this
and automatically register the Apple CA certificate chain so it is included
in the digital signature. This matches the behavior of the `codesign` tool.

For best results, put your private key and its corresponding X.509 certificate
in a single file, either a PFX or PEM formatted file. Then add any additional
certificates constituting the signing chain in a separate PEM file.

When using a code signing key/certificate, a Time-Stamp Protocol server URL
can be specified via --timestamp-url. By default, Apple's server is used. The
special value \"none\" can disable using a timestamp server.

# Selecting What to Sign

By default, this command attempts to recursively sign everything in the source
path. This applies to:

* Bundles. If the specified bundle has nested bundles, those nested bundles
  will be signed automatically.

It is possible to exclude nested items from signing using --exclude. This
argument takes a glob expression that matches *relative paths* from the
source path. Glob expressions can be literal string compares. Or the
following special syntax is recognized:

* `?` matches any single character.
* `*` matches any (possibly empty) sequence of characters.
* `**` matches the current directory and arbitrary subdirectories. This sequence
  must form a single path component, so both **a and b** are invalid and will
  result in an error. A sequence of more than two consecutive * characters is
  also invalid.
* `[...]` matches any character inside the brackets. Character sequences can also
  specify ranges of characters, as ordered by Unicode, so e.g. [0-9] specifies any
  character between 0 and 9 inclusive. An unclosed bracket is invalid.
* `[!...]` is the negation of `[...]`, i.e. it matches any characters not in the
  brackets.
* The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g.
  `[?]`). When a `]` occurs immediately following `[` or `[!` then it is
  interpreted as being part of, rather then ending, the character set, so `]` and
  `NOT ]` can be matched by `[]]` and `[!]]` respectively. The `-` character can
  be specified inside a character sequence pattern by placing it at the start or
  the end, e.g. `[abc-]`.

Currently, --exclude only applies to the relative path of nested bundles within
the main bundle to sign. e.g. if you sign `MyApp.app` and it has a
`Contents/Frameworks/MyFramework.framework` that you wish to exclude, you would
`--exclude Contents/Frameworks/MyFramework.framework` or even
`--exclude Contents/Frameworks/**` to exclude the entire directory tree.

Exclusions will still be copied and parents that need to reference exclude
entities will continue to do so. If you wish to make a file or directory
disappear, create a new directory without the file(s) and sign that.

To exclude all nested bundles from being signed and only sign the main bundle
(the default behavior of ``codesign`` without ``--deep``), use `--exclude '**'`.
";

const APPLE_TIMESTAMP_URL: &str = "http://timestamp.apple.com/ts01";

#[allow(unused)]
pub fn prompt_smartcard_pin() -> Result<Vec<u8>, AppleCodesignError> {
    let pin = dialoguer::Password::new()
        .with_prompt("Please enter device PIN")
        .interact()?;

    Ok(pin.as_bytes().to_vec())
}

pub fn get_pkcs12_password(
    password: Option<impl ToString>,
    password_file: Option<impl AsRef<Path>>,
) -> Result<String, AppleCodesignError> {
    if let Some(password) = password {
        Ok(password.to_string())
    } else if let Some(path) = password_file {
        Ok(std::fs::read_to_string(path.as_ref())?
            .lines()
            .next()
            .ok_or_else(|| {
                AppleCodesignError::CliGeneralError("password file appears to be empty".into())
            })?
            .to_string())
    } else {
        Ok(dialoguer::Password::new()
            .with_prompt("Please enter password for p12 file")
            .interact()?)
    }
}

#[cfg(feature = "notarize")]
#[derive(Args)]
struct NotaryApi {
    /// Path to a JSON file containing the API Key
    #[arg(
        long = "api-key-file",
        alias = "api-key-path",
        group = "source",
        value_name = "PATH"
    )]
    api_key_path: Option<PathBuf>,

    /// App Store Connect Issuer ID (likely a UUID)
    #[arg(long, requires = "api_key")]
    api_issuer: Option<String>,

    #[arg(long, requires = "api_issuer")]
    /// App Store Connect API Key ID
    api_key: Option<String>,
}

#[cfg(feature = "notarize")]
impl NotaryApi {
    /// Resolve a notarizer from arguments.
    fn notarizer(&self) -> Result<Notarizer, AppleCodesignError> {
        if let Some(api_key_path) = &self.api_key_path {
            Notarizer::from_api_key(api_key_path)
        } else if let (Some(issuer), Some(key)) = (&self.api_issuer, &self.api_key) {
            Notarizer::from_api_key_id(issuer, key)
        } else {
            Err(AppleCodesignError::NotarizeNoAuthCredentials)
        }
    }
}

#[derive(Args)]
struct YubikeyPolicy {
    /// Smartcard touch policy to protect key access
    #[arg(long, value_parser = ["default", "always", "never", "cached"], default_value = "default")]
    touch_policy: String,

    /// Smartcard pin prompt policy to protect key access
    #[arg(long, value_parser = ["default", "never", "once", "always"], default_value = "default")]
    pin_policy: String,
}

#[cfg(feature = "yubikey")]
fn str_to_touch_policy(s: &str) -> Result<TouchPolicy, AppleCodesignError> {
    match s {
        "default" => Ok(TouchPolicy::Default),
        "never" => Ok(TouchPolicy::Never),
        "always" => Ok(TouchPolicy::Always),
        "cached" => Ok(TouchPolicy::Cached),
        _ => Err(AppleCodesignError::CliBadArgument),
    }
}

#[cfg(feature = "yubikey")]
fn str_to_pin_policy(s: &str) -> Result<PinPolicy, AppleCodesignError> {
    match s {
        "default" => Ok(PinPolicy::Default),
        "never" => Ok(PinPolicy::Never),
        "once" => Ok(PinPolicy::Once),
        "always" => Ok(PinPolicy::Always),
        _ => Err(AppleCodesignError::CliBadArgument),
    }
}

fn print_certificate_info(cert: &CapturedX509Certificate) -> Result<(), AppleCodesignError> {
    println!(
        "Subject CN:                  {}",
        cert.subject_common_name()
            .unwrap_or_else(|| "<missing>".to_string())
    );
    println!(
        "Issuer CN:                   {}",
        cert.issuer_common_name()
            .unwrap_or_else(|| "<missing>".to_string())
    );
    println!("Subject is Issuer?:          {}", cert.subject_is_issuer());
    println!(
        "Team ID:                     {}",
        cert.apple_team_id()
            .unwrap_or_else(|| "<missing>".to_string())
    );
    println!(
        "SHA-1 fingerprint:           {}",
        hex::encode(cert.sha1_fingerprint()?)
    );
    println!(
        "SHA-256 fingerprint:         {}",
        hex::encode(cert.sha256_fingerprint()?)
    );
    if let Some(alg) = cert.key_algorithm() {
        println!("Key Algorithm:               {alg}");
    }
    if let Some(alg) = cert.signature_algorithm() {
        println!("Signature Algorithm:         {alg}");
    }
    println!(
        "Public Key Data:             {}",
        STANDARD_ENGINE.encode(
            cert.to_public_key_der()
                .map_err(|e| AppleCodesignError::X509Parse(format!(
                    "error constructing SPKI: {e}"
                )))?
        )
    );
    println!(
        "Signed by Apple?:            {}",
        cert.chains_to_apple_root_ca()
    );
    if cert.chains_to_apple_root_ca() {
        println!("Apple Issuing Chain:");
        for signer in cert.apple_issuing_chain() {
            println!(
                "  - {}",
                signer
                    .subject_common_name()
                    .unwrap_or_else(|| "<unknown>".to_string())
            );
        }
    }

    println!(
        "Guessed Certificate Profile: {}",
        if let Some(profile) = cert.apple_guess_profile() {
            format!("{profile:?}")
        } else {
            "none".to_string()
        }
    );
    println!("Is Apple Root CA?:           {}", cert.is_apple_root_ca());
    println!(
        "Is Apple Intermediate CA?:   {}",
        cert.is_apple_intermediate_ca()
    );

    if !cert.apple_ca_extensions().is_empty() {
        println!("Apple CA Extensions:");
        for ext in cert.apple_ca_extensions() {
            println!("  - {} ({:?})", ext.as_oid(), ext);
        }
    }

    println!("Apple Extended Key Usage Purpose Extensions:");
    for purpose in cert.apple_extended_key_usage_purposes() {
        println!("  - {} ({:?})", purpose.as_oid(), purpose);
    }
    println!("Apple Code Signing Extensions:");
    for ext in cert.apple_code_signing_extensions() {
        println!("  - {} ({:?})", ext.as_oid(), ext);
    }
    print!(
        "\n{}",
        cert.to_public_key_pem(Default::default())
            .map_err(|e| AppleCodesignError::X509Parse(format!("error constructing SPKI: {e}")))?
    );
    print!("\n{}", cert.encode_pem());

    Ok(())
}

pub fn print_session_join(sjs_base64: &str, sjs_pem: &str) -> Result<(), RemoteSignError> {
    error!("");
    error!("Run the following command to join this signing session:");
    error!("");
    error!("    rcodesign remote-sign {}", sjs_base64);
    error!("");
    error!("Or if this output is too long, paste the following output:");
    error!("");
    for line in sjs_pem.lines() {
        error!("{}", line);
    }
    error!("");
    error!("Into an interactive editor using:");
    error!("");
    error!("    rcodesign remote-sign --editor");
    error!("");
    error!("Or into a new file whose path you define with:");
    error!("");
    error!("    rcodesign remote-sign --sjs-path /path/to/file/you/just/saved");
    error!("");
    error!("(waiting for remote signer to join)");

    Ok(())
}

#[derive(Parser)]
struct AnalyzeCertificate {
    #[command(flatten)]
    certificate: CertificateSource,
}

impl AnalyzeCertificate {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let certs = self.certificate.resolve_certificates(true)?.certs;

        for (i, cert) in certs.into_iter().enumerate() {
            println!("# Certificate {i}");
            println!();
            print_certificate_info(&cert)?;
            println!();
        }

        Ok(())
    }
}

#[derive(Parser)]
struct ComputeCodeHashes {
    /// Path to Mach-O binary to examine.
    path: PathBuf,

    /// Hashing algorithm to use.
    #[arg(long, default_value_t = DigestType::Sha256)]
    hash: DigestType,

    /// Chunk size to digest over.
    #[arg(long, default_value = "4096")]
    page_size: usize,

    /// Index of Mach-O binary to operate on within a universal/fat binary
    #[arg(long, default_value = "0")]
    universal_index: usize,
}

impl ComputeCodeHashes {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let data = std::fs::read(&self.path)?;
        let mach = MachFile::parse(&data)?;
        let macho = mach.nth_macho(self.universal_index)?;

        let hashes = macho.code_digests(self.hash, self.page_size)?;

        for hash in hashes {
            println!("{}", hex::encode(hash));
        }

        Ok(())
    }
}

#[derive(Parser)]
struct DiffSignatures {
    /// The first path to compare
    path0: PathBuf,

    /// The second path to compare
    path1: PathBuf,
}

impl DiffSignatures {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let reader = SignatureReader::from_path(&self.path0)?;

        let a_entities = reader.entities()?;

        let reader = SignatureReader::from_path(&self.path1)?;
        let b_entities = reader.entities()?;

        let a = serde_yaml::to_string(&a_entities)?;
        let b = serde_yaml::to_string(&b_entities)?;

        let Changeset { diffs, .. } = Changeset::new(&a, &b, "\n");

        for item in diffs {
            match item {
                Difference::Same(ref x) => {
                    for line in x.lines() {
                        println!(" {line}");
                    }
                }
                Difference::Add(ref x) => {
                    for line in x.lines() {
                        println!("+{line}");
                    }
                }
                Difference::Rem(ref x) => {
                    for line in x.lines() {
                        println!("-{line}");
                    }
                }
            }
        }

        Ok(())
    }
}

#[cfg(feature = "notarize")]
const ENCODE_APP_STORE_CONNECT_API_KEY_ABOUT: &str = "\
Encode an App Store Connect API Key to JSON.

App Store Connect API Keys
(https://developer.apple.com/documentation/appstoreconnectapi/creating_api_keys_for_app_store_connect_api)
are defined by 3 components:

* The Issuer ID (likely a UUID)
* A Key ID (an alphanumeric value like `DEADBEEF42`)
* A PEM encoded ECDSA private key (typically a file beginning with
  `-----BEGIN PRIVATE KEY-----`).

This command is used to encode all API Key components into a single JSON
object so you only have to refer to a single entity when performing
operations (like notarization) using these API Keys.

The API Key components are specified as positional arguments.

By default, the JSON encoded unified representation is printed to stdout.
You can write to a file instead by passing `--output-path <path>`.

# Security Considerations

The App Store Connect API Key contains a private key and its value should be
treated as sensitive: if an unwanted party obtains your private key, they
effectively have access to your App Store Connect account.

When this command writes JSON files, an attempt is made to limit access
to the file. However, file access restrictions may not be as secure as you
want. Security conscious individuals should audit the permissions of the
file and adjust accordingly.
";

#[cfg(feature = "notarize")]
#[derive(Parser)]
struct EncodeAppStoreConnectApiKey {
    /// Path to a JSON file to create the output to
    #[arg(short = 'o', long)]
    output_path: Option<PathBuf>,

    /// The issuer of the API Token. Likely a UUID
    issuer_id: String,

    /// The Key ID. A short alphanumeric string like DEADBEEF42
    key_id: String,

    /// Path to a file containing the private key downloaded from Apple
    private_key_path: PathBuf,
}

#[cfg(feature = "notarize")]
impl EncodeAppStoreConnectApiKey {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let unified = app_store_connect::UnifiedApiKey::from_ecdsa_pem_path(
            &self.issuer_id,
            &self.key_id,
            &self.private_key_path,
        )?;

        if let Some(output_path) = &self.output_path {
            eprintln!("writing unified key JSON to {}", output_path.display());
            unified.write_json_file(output_path)?;
            eprintln!(
                "consider auditing the file's access permissions to ensure its content remains secure"
            );
        } else {
            println!("{}", unified.to_json_string()?);
        }

        Ok(())
    }
}

fn print_signed_data(
    prefix: &str,
    signed_data: &SignedData,
    external_content: Option<Vec<u8>>,
) -> Result<(), AppleCodesignError> {
    println!(
        "{}signed content (embedded): {:?}",
        prefix,
        signed_data.signed_content().map(hex::encode)
    );
    println!(
        "{}signed content (external): {:?}... ({} bytes)",
        prefix,
        external_content.as_ref().map(|x| hex::encode(&x[0..40])),
        external_content.as_ref().map(|x| x.len()).unwrap_or(0),
    );

    let content = if let Some(v) = signed_data.signed_content() {
        Some(v)
    } else {
        external_content.as_ref().map(|v| v.as_ref())
    };

    if let Some(content) = content {
        println!(
            "{}signed content SHA-1:   {}",
            prefix,
            hex::encode(DigestType::Sha1.digest_data(content)?)
        );
        println!(
            "{}signed content SHA-256: {}",
            prefix,
            hex::encode(DigestType::Sha256.digest_data(content)?)
        );
        println!(
            "{}signed content SHA-384: {}",
            prefix,
            hex::encode(DigestType::Sha384.digest_data(content)?)
        );
        println!(
            "{}signed content SHA-512: {}",
            prefix,
            hex::encode(DigestType::Sha512.digest_data(content)?)
        );
    }
    println!(
        "{}certificate count: {}",
        prefix,
        signed_data.certificates().count()
    );
    for (i, cert) in signed_data.certificates().enumerate() {
        println!(
            "{}certificate #{}: subject CN={}; self signed={}",
            prefix,
            i,
            cert.subject_common_name()
                .unwrap_or_else(|| "<unknown>".to_string()),
            cert.subject_is_issuer()
        );
    }
    println!("{}signer count: {}", prefix, signed_data.signers().count());
    for (i, signer) in signed_data.signers().enumerate() {
        println!(
            "{}signer #{}: digest algorithm: {:?}",
            prefix,
            i,
            signer.digest_algorithm()
        );
        println!(
            "{}signer #{}: signature algorithm: {:?}",
            prefix,
            i,
            signer.signature_algorithm()
        );

        if let Some(sa) = signer.signed_attributes() {
            println!(
                "{}signer #{}: content type: {}",
                prefix,
                i,
                sa.content_type()
            );
            println!(
                "{}signer #{}: message digest: {}",
                prefix,
                i,
                hex::encode(sa.message_digest())
            );
            println!(
                "{}signer #{}: signing time: {:?}",
                prefix,
                i,
                sa.signing_time()
            );
        }

        let digested_data = signer.signed_content_with_signed_data(signed_data);

        println!(
            "{}signer #{}: signature content SHA-1:   {}",
            prefix,
            i,
            hex::encode(DigestType::Sha1.digest_data(&digested_data)?)
        );
        println!(
            "{}signer #{}: signature content SHA-256: {}",
            prefix,
            i,
            hex::encode(DigestType::Sha256.digest_data(&digested_data)?)
        );
        println!(
            "{}signer #{}: signature content SHA-384: {}",
            prefix,
            i,
            hex::encode(DigestType::Sha384.digest_data(&digested_data)?)
        );
        println!(
            "{}signer #{}: signature content SHA-512: {}",
            prefix,
            i,
            hex::encode(DigestType::Sha512.digest_data(&digested_data)?)
        );

        if signed_data.signed_content().is_some() {
            println!(
                "{}signer #{}: digest valid: {}",
                prefix,
                i,
                signer
                    .verify_message_digest_with_signed_data(signed_data)
                    .is_ok()
            );
        }
        println!(
            "{}signer #{}: signature valid: {}",
            prefix,
            i,
            signer
                .verify_signature_with_signed_data(signed_data)
                .is_ok()
        );

        println!(
            "{}signer #{}: time-stamp token present: {}",
            prefix,
            i,
            signer.time_stamp_token_signed_data()?.is_some()
        );

        if let Some(tsp_signed_data) = signer.time_stamp_token_signed_data()? {
            let prefix = format!("{prefix}signer #{i}: time-stamp token: ");

            print_signed_data(&prefix, &tsp_signed_data, None)?;
        }
    }

    Ok(())
}

#[derive(Clone, Parser)]
struct ExtractCommon {
    /// Path to Mach-O binary to examine
    path: PathBuf,
}

#[derive(Clone, Subcommand)]
enum ExtractData {
    /// Code directory blobs.
    Blobs(ExtractCommon),
    /// Information about cryptographic message syntax signature.
    CmsInfo(ExtractCommon),
    /// PEM encoded cryptographic message syntax signature.
    CmsPem(ExtractCommon),
    /// Binary cryptographic message syntax signature. Should be BER encoded ASN.1 data.
    CmsRaw(ExtractCommon),
    /// ASN.1 decoded cryptographic message syntax data.
    Cms(ExtractCommon),
    /// Information from the main code directory data structure.
    CodeDirectory(ExtractCommon),
    /// Raw binary data composing the code directory data structure.
    CodeDirectoryRaw(ExtractCommon),
    /// Reserialize the parsed code directory, parse it again, and then print it like `code-directory` would.
    CodeDirectorySerialized(ExtractCommon),
    /// Reserialize the parsed code directory and emit its binary.
    ///
    /// Useful for comparing round-tripping of code directory data.
    CodeDirectorySerializedRaw(ExtractCommon),
    /// Information about the __LINKEDIT Mach-O segment.
    LinkeditInfo(ExtractCommon),
    /// Complete content of the __LINKEDIT Mach-O segment.
    LinkeditSegmentRaw(ExtractCommon),
    /// Mach-O file header data.
    MachoHeader(ExtractCommon),
    /// High-level information about Mach-O load commands.
    MachoLoadCommands(ExtractCommon),
    /// Debug formatted Mach-O load command data structures.
    MachoLoadCommandsRaw(ExtractCommon),
    /// Information about Mach-O segments.
    MachoSegments(ExtractCommon),
    /// Mach-O targeting info.
    MachoTarget(ExtractCommon),
    /// Parsed code requirement statement/expression.
    Requirements(ExtractCommon),
    /// Raw binary data composing the requirements blob/slot.
    RequirementsRaw(ExtractCommon),
    /// Dump the internal Rust data structures representing the requirements expressions.
    RequirementsRust(ExtractCommon),
    /// Reserialize the code requirements blob, parse it again, and then print it like `requirements` would.
    RequirementsSerialized(ExtractCommon),
    /// Like `requirements-serialized` except emit the binary data representation.
    RequirementsSerializedRaw(ExtractCommon),
    /// Raw binary data constituting the signature data embedded in the binary.
    SignatureRaw(ExtractCommon),
    /// Show information about the SuperBlob record and high-level details of embedded Blob records.
    Superblob(ExtractCommon),
}

impl ExtractData {
    fn common_args(&self) -> &ExtractCommon {
        match self {
            ExtractData::Blobs(x) => x,
            ExtractData::CmsInfo(x) => x,
            ExtractData::CmsPem(x) => x,
            ExtractData::CmsRaw(x) => x,
            ExtractData::Cms(x) => x,
            ExtractData::CodeDirectoryRaw(x) => x,
            ExtractData::CodeDirectorySerializedRaw(x) => x,
            ExtractData::CodeDirectorySerialized(x) => x,
            ExtractData::CodeDirectory(x) => x,
            ExtractData::LinkeditInfo(x) => x,
            ExtractData::LinkeditSegmentRaw(x) => x,
            ExtractData::MachoHeader(x) => x,
            ExtractData::MachoLoadCommands(x) => x,
            ExtractData::MachoLoadCommandsRaw(x) => x,
            ExtractData::MachoSegments(x) => x,
            ExtractData::MachoTarget(x) => x,
            ExtractData::RequirementsRaw(x) => x,
            ExtractData::RequirementsRust(x) => x,
            ExtractData::RequirementsSerializedRaw(x) => x,
            ExtractData::RequirementsSerialized(x) => x,
            ExtractData::Requirements(x) => x,
            ExtractData::SignatureRaw(x) => x,
            ExtractData::Superblob(x) => x,
        }
    }
}

#[derive(Parser)]
struct Extract {
    /// Index of Mach-O binary to operate on within a universal/fat binary
    #[arg(long, global = true, default_value = "0")]
    universal_index: usize,

    /// Which data to extract and how to format it
    #[command(subcommand)]
    data: ExtractData,
}

impl Extract {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let common = self.data.common_args();

        let data = std::fs::read(&common.path)?;
        let mach = MachFile::parse(&data)?;
        let macho = mach.nth_macho(self.universal_index)?;

        match self.data {
            ExtractData::Blobs(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                for blob in embedded.blobs {
                    let parsed = blob.into_parsed_blob()?;
                    println!("{parsed:#?}");
                }
            }
            ExtractData::CmsInfo(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(cms) = embedded.signature_data()? {
                    let signed_data = SignedData::parse_ber(cms)?;

                    let cd_data = if let Ok(Some(blob)) = embedded.code_directory() {
                        Some(blob.to_blob_bytes()?)
                    } else {
                        None
                    };

                    print_signed_data("", &signed_data, cd_data)?;
                } else {
                    eprintln!("no CMS data");
                }
            }
            ExtractData::CmsPem(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(cms) = embedded.signature_data()? {
                    print!("{}", pem::encode(&pem::Pem::new("PKCS7", cms.to_vec())));
                } else {
                    eprintln!("no CMS data");
                }
            }
            ExtractData::CmsRaw(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(cms) = embedded.signature_data()? {
                    std::io::stdout().write_all(cms)?;
                } else {
                    eprintln!("no CMS data");
                }
            }
            ExtractData::Cms(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(signed_data) = embedded.signed_data()? {
                    println!("{signed_data:#?}");
                } else {
                    eprintln!("no CMS data");
                }
            }
            ExtractData::CodeDirectoryRaw(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(blob) = embedded.find_slot(CodeSigningSlot::CodeDirectory) {
                    std::io::stdout().write_all(blob.data)?;
                } else {
                    eprintln!("no code directory");
                }
            }
            ExtractData::CodeDirectorySerializedRaw(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Ok(Some(cd)) = embedded.code_directory() {
                    std::io::stdout().write_all(&cd.to_blob_bytes()?)?;
                } else {
                    eprintln!("no code directory");
                }
            }
            ExtractData::CodeDirectorySerialized(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Ok(Some(cd)) = embedded.code_directory() {
                    let serialized = cd.to_blob_bytes()?;
                    println!("{:#?}", CodeDirectoryBlob::from_blob_bytes(&serialized)?);
                }
            }
            ExtractData::CodeDirectory(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(cd) = embedded.code_directory()? {
                    println!("{cd:#?}");
                } else {
                    eprintln!("no code directory");
                }
            }
            ExtractData::LinkeditInfo(_) => {
                let sig = macho
                    .find_signature_data()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;
                println!("__LINKEDIT segment index: {}", sig.linkedit_segment_index);
                println!(
                    "__LINKEDIT segment start offset: {}",
                    sig.linkedit_segment_start_offset
                );
                println!(
                    "__LINKEDIT segment end offset: {}",
                    sig.linkedit_segment_end_offset
                );
                println!(
                    "__LINKEDIT segment size: {}",
                    sig.linkedit_segment_data.len()
                );
                println!(
                    "__LINKEDIT signature global start offset: {}",
                    sig.signature_file_start_offset
                );
                println!(
                    "__LINKEDIT signature global end offset: {}",
                    sig.signature_file_end_offset
                );
                println!(
                    "__LINKEDIT signature local segment start offset: {}",
                    sig.signature_segment_start_offset
                );
                println!(
                    "__LINKEDIT signature local segment end offset: {}",
                    sig.signature_segment_end_offset
                );
                println!("__LINKEDIT signature size: {}", sig.signature_data.len());
            }
            ExtractData::LinkeditSegmentRaw(_) => {
                let sig = macho
                    .find_signature_data()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;
                std::io::stdout().write_all(sig.linkedit_segment_data)?;
            }
            ExtractData::MachoHeader(_) => {
                println!("{:#?}", macho.macho.header);
            }
            ExtractData::MachoLoadCommands(_) => {
                println!("load command count: {}", macho.macho.load_commands.len());

                for command in &macho.macho.load_commands {
                    println!(
                        "{}; offsets=0x{:x}-0x{:x} ({}-{}); size={}",
                        goblin::mach::load_command::cmd_to_str(command.command.cmd()),
                        command.offset,
                        command.offset + command.command.cmdsize(),
                        command.offset,
                        command.offset + command.command.cmdsize(),
                        command.command.cmdsize(),
                    );
                }
            }
            ExtractData::MachoLoadCommandsRaw(_) => {
                for command in &macho.macho.load_commands {
                    println!("{:?}", command);
                }
            }
            ExtractData::MachoSegments(_) => {
                println!("segments count: {}", macho.macho.segments.len());
                for (segment_index, segment) in macho.macho.segments.iter().enumerate() {
                    let sections = segment.sections()?;

                    println!(
                    "segment #{}; {}; offsets=0x{:x}-0x{:x} ({}-{}); addresses=0x{:x}-0x{:x}; vm/file size {}/{}; section count {}",
                    segment_index,
                    segment.name()?,
                    segment.fileoff,
                    segment.fileoff as usize + segment.data.len(),
                    segment.fileoff,
                    segment.fileoff as usize + segment.data.len(),
                    segment.vmaddr,
                    segment.vmaddr + segment.vmsize,
                    segment.vmsize,
                    segment.filesize,
                    sections.len()
                );
                    for (section_index, (section, _)) in sections.into_iter().enumerate() {
                        println!(
                        "segment #{}; section #{}: {}; offsets=0x{:x}-0x{:x} ({}-{}); addresses=0x{:x}-0x{:x}; size {}; align={}; flags={}",
                        segment_index,
                        section_index,
                        section.name()?,
                        section.offset,
                        section.offset as u64 + section.size,
                        section.offset,
                        section.offset as u64 + section.size,
                        section.addr,
                        section.addr + section.size,
                        section.size,
                        section.align,
                        section.flags,
                    );
                    }
                }
            }
            ExtractData::MachoTarget(_) => {
                if let Some(target) = macho.find_targeting()? {
                    println!("Platform: {}", target.platform);
                    println!("Minimum OS: {}", target.minimum_os_version);
                    println!("SDK: {}", target.sdk_version);
                } else {
                    println!("Unable to resolve Mach-O targeting from load commands");
                }
            }
            ExtractData::RequirementsRaw(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(blob) = embedded.find_slot(CodeSigningSlot::RequirementSet) {
                    std::io::stdout().write_all(blob.data)?;
                } else {
                    eprintln!("no requirements");
                }
            }
            ExtractData::RequirementsRust(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(reqs) = embedded.code_requirements()? {
                    for (typ, req) in &reqs.requirements {
                        for expr in req.parse_expressions()?.iter() {
                            println!("{typ} => {expr:#?}");
                        }
                    }
                } else {
                    eprintln!("no requirements");
                }
            }
            ExtractData::RequirementsSerializedRaw(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(reqs) = embedded.code_requirements()? {
                    std::io::stdout().write_all(&reqs.to_blob_bytes()?)?;
                } else {
                    eprintln!("no requirements");
                }
            }
            ExtractData::RequirementsSerialized(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(reqs) = embedded.code_requirements()? {
                    let serialized = reqs.to_blob_bytes()?;
                    println!("{:#?}", RequirementSetBlob::from_blob_bytes(&serialized)?);
                } else {
                    eprintln!("no requirements");
                }
            }
            ExtractData::Requirements(_) => {
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                if let Some(reqs) = embedded.code_requirements()? {
                    for (typ, req) in &reqs.requirements {
                        for expr in req.parse_expressions()?.iter() {
                            println!("{typ} => {expr}");
                        }
                    }
                } else {
                    eprintln!("no requirements");
                }
            }
            ExtractData::SignatureRaw(_) => {
                let sig = macho
                    .find_signature_data()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;
                std::io::stdout().write_all(sig.signature_data)?;
            }
            ExtractData::Superblob(_) => {
                let sig = macho
                    .find_signature_data()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;
                let embedded = macho
                    .code_signature()?
                    .ok_or(AppleCodesignError::BinaryNoCodeSignature)?;

                println!("file start offset: {}", sig.signature_file_start_offset);
                println!("file end offset: {}", sig.signature_file_end_offset);
                println!(
                    "__LINKEDIT start offset: {}",
                    sig.signature_segment_start_offset
                );
                println!(
                    "__LINKEDIT end offset: {}",
                    sig.signature_segment_end_offset
                );
                println!("length: {}", embedded.length);
                println!("blob count: {}", embedded.count);
                println!("blobs:");
                for blob in embedded.blobs {
                    println!("- index: {}", blob.index);
                    println!(
                        "  offsets: 0x{:x}-0x{:x} ({}-{})",
                        blob.offset,
                        blob.offset + blob.length - 1,
                        blob.offset,
                        blob.offset + blob.length - 1
                    );
                    println!("  length: {}", blob.length);
                    println!("  slot: {:?}", blob.slot);
                    println!("  magic: {:?} (0x{:x})", blob.magic, u32::from(blob.magic));
                    println!(
                        "  sha1: {}",
                        hex::encode(blob.digest_with(DigestType::Sha1)?)
                    );
                    println!(
                        "  sha256: {}",
                        hex::encode(blob.digest_with(DigestType::Sha256)?)
                    );
                    println!(
                        "  sha256-truncated: {}",
                        hex::encode(blob.digest_with(DigestType::Sha256Truncated)?)
                    );
                    println!(
                        "  sha384: {}",
                        hex::encode(blob.digest_with(DigestType::Sha384)?),
                    );
                    println!(
                        "  sha512: {}",
                        hex::encode(blob.digest_with(DigestType::Sha512)?),
                    );
                    println!(
                        "  sha1-base64: {}",
                        STANDARD_ENGINE.encode(blob.digest_with(DigestType::Sha1)?)
                    );
                    println!(
                        "  sha256-base64: {}",
                        STANDARD_ENGINE.encode(blob.digest_with(DigestType::Sha256)?)
                    );
                    println!(
                        "  sha256-truncated-base64: {}",
                        STANDARD_ENGINE.encode(blob.digest_with(DigestType::Sha256Truncated)?)
                    );
                    println!(
                        "  sha384-base64: {}",
                        STANDARD_ENGINE.encode(blob.digest_with(DigestType::Sha384)?)
                    );
                    println!(
                        "  sha512-base64: {}",
                        STANDARD_ENGINE.encode(blob.digest_with(DigestType::Sha512)?)
                    );
                }
            }
        }

        Ok(())
    }
}

#[derive(Parser)]
struct GenerateCertificateSigningRequest {
    /// Path to file to write PEM encoded CSR to
    #[arg(long = "csr-pem-file", alias = "csr-pem-path")]
    csr_pem_path: Option<PathBuf>,

    #[command(flatten)]
    certificate: CertificateSource,
}

impl GenerateCertificateSigningRequest {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let signing_certs = self.certificate.resolve_certificates(true)?;

        let private_key = signing_certs.private_key()?;

        let mut builder = X509CertificateBuilder::default();
        builder
            .subject()
            .append_common_name_utf8_string("Apple Code Signing CSR")
            .map_err(|e| AppleCodesignError::CertificateBuildError(format!("{e:?}")))?;

        warn!("generating CSR; you may be prompted to enter credentials to unlock the signing key");
        let pem = builder
            .create_certificate_signing_request(private_key.as_key_info_signer())?
            .encode_pem()?;

        if let Some(dest_path) = &self.csr_pem_path {
            if let Some(parent) = dest_path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            warn!("writing PEM encoded CSR to {}", dest_path.display());
            std::fs::write(dest_path, pem.as_bytes())?;
        }

        print!("{pem}");

        Ok(())
    }
}

#[derive(Parser)]
struct GenerateSelfSignedCertificate {
    /// Which key type to use
    #[arg(long, value_parser = ["ecdsa", "ed25519", "rsa"], default_value = "rsa")]
    algorithm: String,

    #[arg(long, value_parser = CertificateProfile::str_names(), default_value = "apple-development")]
    profile: String,

    /// Team ID (this is a short string attached to your Apple Developer account)
    #[arg(long, default_value = "unset")]
    team_id: String,

    /// The name of the person this certificate is for
    #[arg(long)]
    person_name: String,

    /// Country Name (C) value for certificate identifier
    #[arg(long, default_value = "XX")]
    country_name: String,

    /// How many days the certificate should be valid for
    #[arg(long, default_value = "365")]
    validity_days: i64,

    /// Base name of files to write PEM encoded certificate to
    #[arg(long)]
    pem_filename: Option<String>,

    /// Filename to write PEM encoded private key and public certificate to.
    #[arg(
        long = "pem-unified-file",
        alias = "pem-unified-filename",
        value_name = "PATH"
    )]
    pem_unified_path: Option<PathBuf>,

    /// Filename to write a PKCS#12 / p12 / PFX encoded certificate to.
    #[arg(long = "p12-file", alias = "pfx-file", value_name = "PATH")]
    p12_path: Option<PathBuf>,

    /// Password to use to encrypt --p12-path.
    ///
    /// If not provided you will be prompted for a password.
    #[arg(long)]
    p12_password: Option<String>,
}

impl GenerateSelfSignedCertificate {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let algorithm = match self.algorithm.as_str() {
            "ecdsa" => KeyAlgorithm::Ecdsa(EcdsaCurve::Secp256r1),
            "ed25519" => KeyAlgorithm::Ed25519,
            "rsa" => KeyAlgorithm::Rsa,
            value => panic!("algorithm values should have been validated by arg parser: {value}"),
        };

        let profile = CertificateProfile::from_str(self.profile.as_str())?;

        let validity_duration = chrono::Duration::days(self.validity_days);

        let (cert, key_pair) = create_self_signed_code_signing_certificate(
            algorithm,
            profile,
            &self.team_id,
            &self.person_name,
            &self.country_name,
            validity_duration,
        )?;

        let cert_pem = cert.encode_pem();
        let key_pem = pem::encode(&pem::Pem::new(
            "PRIVATE KEY",
            key_pair.to_pkcs8_one_asymmetric_key_der().to_vec(),
        ));

        let mut wrote_file = false;

        if let Some(pem_filename) = &self.pem_filename {
            let cert_path = PathBuf::from(format!("{pem_filename}.crt"));
            let key_path = PathBuf::from(format!("{pem_filename}.key"));

            if let Some(parent) = cert_path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            println!("writing public certificate to {}", cert_path.display());
            std::fs::write(&cert_path, cert_pem.as_bytes())?;
            println!("writing private signing key to {}", key_path.display());
            std::fs::write(&key_path, key_pem.as_bytes())?;

            wrote_file = true;
        }

        if let Some(path) = &self.pem_unified_path {
            let content = format!("{}{}", key_pem, cert_pem);

            if let Some(parent) = path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            println!("writing unified PEM to {}", path.display());
            std::fs::write(path, content.as_bytes())?;

            wrote_file = true;
        }

        if let Some(path) = &self.p12_path {
            let password = get_pkcs12_password(self.p12_password.clone(), None::<PathBuf>)?;

            let pfx = p12::PFX::new(
                &cert.encode_der()?,
                &key_pair.to_pkcs8_one_asymmetric_key_der(),
                None,
                &password,
                "code-signing",
            )
            .ok_or_else(|| {
                AppleCodesignError::CliGeneralError("failed to create PFX structure".into())
            })?;

            println!("writing PKCS#12 certificate to {}", path.display());

            if let Some(parent) = path.parent() {
                std::fs::create_dir_all(parent)?;
            }
            std::fs::write(path, pfx.to_der())?;

            wrote_file = true;
        }

        if !wrote_file {
            print!("{cert_pem}");
            print!("{key_pem}");
        }

        Ok(())
    }
}

#[derive(Parser)]
struct KeychainExportCertificateChain {
    /// Keychain domain to operate on
    #[arg(long, value_parser = KEYCHAIN_DOMAINS, default_value = "user")]
    domain: String,

    /// Password to unlock the Keychain
    #[arg(long, group = "unlock-password")]
    password: Option<String>,

    /// File containing password to use to unlock the Keychain
    #[arg(long = "password-file", group = "unlock-password")]
    password_path: Option<PathBuf>,

    /// Print only the issuing certificate chain, not the subject certificate
    #[arg(long)]
    no_print_self: bool,

    /// User ID value of code signing certificate to find and whose CA chain to export
    #[arg(long)]
    user_id: String,
}

impl KeychainExportCertificateChain {
    #[cfg(target_os = "macos")]
    fn run(&self) -> Result<(), AppleCodesignError> {
        let domain = KeychainDomain::try_from(self.domain.as_str())
            .expect("clap should have validated domain values");

        let password = if let Some(path) = &self.password_path {
            let data = std::fs::read_to_string(path)?;

            Some(
                data.lines()
                    .next()
                    .expect("should get a single line")
                    .to_string(),
            )
        } else {
            self.password.as_ref().map(|password| password.to_string())
        };

        let certs =
            macos_keychain_find_certificate_chain(domain, password.as_deref(), &self.user_id)?;

        for (i, cert) in certs.iter().enumerate() {
            if self.no_print_self && i == 0 {
                continue;
            }

            print!("{}", cert.encode_pem());
        }

        Ok(())
    }

    #[cfg(not(target_os = "macos"))]
    fn run(&self) -> Result<(), AppleCodesignError> {
        Err(AppleCodesignError::CliGeneralError(
            "macOS Keychain export only supported on macOS".to_string(),
        ))
    }
}

#[derive(Parser)]
struct KeychainPrintCertificates {
    /// Keychain domain to operate on
    #[arg(long, value_parser = KEYCHAIN_DOMAINS, default_value = "user")]
    domain: String,
}

impl KeychainPrintCertificates {
    #[cfg(target_os = "macos")]
    fn run(&self) -> Result<(), AppleCodesignError> {
        let domain = KeychainDomain::try_from(self.domain.as_str())
            .expect("clap should have validated domain values");

        let certs = keychain_find_code_signing_certificates(domain, None)?;

        for (i, cert) in certs.into_iter().enumerate() {
            println!("# Certificate {}", i);
            println!();
            print_certificate_info(&cert)?;
            println!();
        }

        Ok(())
    }

    #[cfg(not(target_os = "macos"))]
    fn run(&self) -> Result<(), AppleCodesignError> {
        Err(AppleCodesignError::CliGeneralError(
            "macOS Keychain integration supported on macOS".to_string(),
        ))
    }
}

#[derive(Parser)]
struct MachoUniversalCreate {
    /// Input Mach-O binaries to combine.
    input: Vec<PathBuf>,

    /// Output file to write.
    #[arg(short = 'o', long)]
    output: PathBuf,
}

impl MachoUniversalCreate {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let mut builder = crate::macho_universal::UniversalBinaryBuilder::default();

        for path in &self.input {
            eprintln!("adding {}", path.display());
            let data = std::fs::read(path)?;
            builder.add_binary(data)?;
        }

        eprintln!("writing {}", self.output.display());

        if let Some(parent) = self.output.parent() {
            std::fs::create_dir_all(parent)?;
        }

        let mut fh = std::fs::File::create(&self.output)?;
        simple_file_manifest::set_executable(&mut fh)?;
        builder.write(&mut fh)?;

        Ok(())
    }
}

#[cfg(feature = "notarize")]
const NOTARIZE_ABOUT: &str = "\
Submit a notarization request to Apple.

This command is used to submit an asset to Apple for notarization. Given
a path to an asset with a code signature, this command will connect to Apple's
Notary API and upload the asset. It will then optionally wait on the submission
to finish processing (which typically takes a few dozen seconds). If the
asset validates Apple's requirements, Apple will issue a *notarization ticket*
as proof that they approved of it. This ticket is then added to the asset in a
process called *stapling*, which this command can do automatically if the
`--staple` argument is passed.

# App Store Connect API Key

In order to communicate with Apple's servers, you need an App Store Connect
API Key. This requires an Apple Developer account. You can generate an
API Key at https://appstoreconnect.apple.com/access/api.

The recommended mechanism to define the API Key is via `--api-key-path`,
which takes the path to a file containing JSON produced by the
`encode-app-store-connect-api-key` command. See that command's help for
more details.

If you don't wish to use `--api-key-path`, you can define the key components
via the `--api-issuer` and `--api-key` arguments. You will need a file named
`AuthKey_<ID>.p8` in one of the following locations: `$(pwd)/private_keys/`,
`~/private_keys/`, '~/.private_keys/`, and `~/.appstoreconnect/private_keys/`
(searched in that order). The name of the file is derived from the value of
`--api-key`.

In all cases, App Store Connect API Keys can be managed at
https://appstoreconnect.apple.com/access/api.

# Modes of Operation

By default, the `notarize` command will initiate an upload to Apple and exit
once the upload is complete.

Once an upload is performed, Apple will asynchronously process the uploaded
content. This can take seconds to minutes.

To poll Apple's servers and wait on the server-side processing to finish,
specify `--wait`. This will query the state of the processing every few seconds
until it is finished, the max wait time is reached, or an error occurs.

To automatically staple an asset after server-side processing has finished,
specify `--staple`. This implies `--wait`.
";

#[cfg(feature = "notarize")]
#[derive(Parser)]
struct NotaryLog {
    /// The ID of the previous submission to wait on
    submission_id: String,

    #[command(flatten)]
    api: NotaryApi,
}

#[cfg(feature = "notarize")]
impl NotaryLog {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let notarizer = self.api.notarizer()?;

        let log = notarizer.fetch_notarization_log(&self.submission_id)?;

        for line in serde_json::to_string_pretty(&log)?.lines() {
            println!("{line}");
        }

        Ok(())
    }
}

#[cfg(feature = "notarize")]
#[derive(Parser)]
struct NotarySubmit {
    /// Whether to wait for upload processing to complete
    #[arg(long)]
    wait: bool,

    /// Maximum time in seconds to wait for the upload result
    #[arg(long, default_value = "600")]
    max_wait_seconds: u64,

    /// Staple the notarization ticket after successful upload (implies --wait)
    #[arg(long)]
    staple: bool,

    /// Path to asset to upload
    path: PathBuf,

    #[command(flatten)]
    api: NotaryApi,
}

#[cfg(feature = "notarize")]
impl NotarySubmit {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let wait = self.wait || self.staple;

        let wait_limit = if wait {
            Some(std::time::Duration::from_secs(self.max_wait_seconds))
        } else {
            None
        };
        let notarizer = self.api.notarizer()?;

        let upload = notarizer.notarize_path(&self.path, wait_limit)?;

        if self.staple {
            match upload {
                crate::notarization::NotarizationUpload::UploadId(_) => {
                    panic!(
                        "NotarizationUpload::UploadId should not be returned if we waited successfully"
                    );
                }
                crate::notarization::NotarizationUpload::NotaryResponse(_) => {
                    let stapler = crate::stapling::Stapler::new()?;
                    stapler.staple_path(&self.path)?;
                }
            }
        }

        Ok(())
    }
}

#[cfg(feature = "notarize")]
#[derive(Parser)]
struct NotaryWait {
    /// Maximum time in seconds to wait for the upload result
    #[arg(long, default_value = "600")]
    max_wait_seconds: u64,

    /// The ID of the previous submission to wait on
    submission_id: String,

    #[command(flatten)]
    api: NotaryApi,
}

#[cfg(feature = "notarize")]
impl NotaryWait {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let wait_duration = std::time::Duration::from_secs(self.max_wait_seconds);
        let notarizer = self.api.notarizer()?;

        notarizer.wait_on_notarization_and_fetch_log(&self.submission_id, wait_duration)?;

        Ok(())
    }
}

#[derive(Parser)]
struct ParseCodeSigningRequirement {
    /// Output format
    #[arg(long, value_parser = ["csrl", "expression-tree"], default_value = "csrl")]
    format: String,

    /// Path to file to parse
    input_path: PathBuf,
}

impl ParseCodeSigningRequirement {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let data = std::fs::read(&self.input_path)?;

        let requirements = CodeRequirements::parse_blob(&data)?.0;

        for requirement in requirements.iter() {
            match self.format.as_str() {
                "csrl" => {
                    println!("{requirement}");
                }
                "expression-tree" => {
                    println!("{requirement:#?}");
                }
                format => panic!("unhandled format: {format}"),
            }
        }

        Ok(())
    }
}

#[derive(Parser)]
struct PrintSignatureInfo {
    /// Filesystem path to entity whose info to print
    path: PathBuf,
}

impl PrintSignatureInfo {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let reader = SignatureReader::from_path(&self.path)?;

        let entities = reader.entities()?;
        serde_yaml::to_writer(std::io::stdout(), &entities)?;

        Ok(())
    }
}

#[derive(Args)]
#[group(required = true, multiple = false)]
struct SessionJoinString {
    /// Open an editor to input the session join string
    #[arg(long = "editor")]
    session_join_string_editor: bool,

    /// Path to file containing session join string
    #[arg(long = "sjs-file", alias = "sjs-path")]
    session_join_string_path: Option<PathBuf>,

    /// Session join string (provided by the signing initiator)
    session_join_string: Option<String>,
}

#[derive(Parser)]
struct RemoteSign {
    #[command(flatten)]
    session_join_string: SessionJoinString,

    #[command(flatten)]
    certificate: CertificateSource,
}

impl RemoteSign {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let session_join_string = if self.session_join_string.session_join_string_editor {
            let mut value = None;

            for _ in 0..3 {
                if let Some(content) = dialoguer::Editor::new()
                    .require_save(true)
                    .edit("# Please enter the -----BEGIN SESSION JOIN STRING---- content below.\n# Remember to save the file!")?
                {
                    value = Some(content);
                    break;
                }
            }

            value.ok_or_else(|| {
                AppleCodesignError::CliGeneralError(
                    "session join string not entered in editor".into(),
                )
            })?
        } else if let Some(path) = &self.session_join_string.session_join_string_path {
            std::fs::read_to_string(path)?
        } else if let Some(value) = &self.session_join_string.session_join_string {
            value.to_string()
        } else {
            return Err(AppleCodesignError::CliGeneralError(
                "session join string argument parsing failure".into(),
            ));
        };

        let mut joiner = create_session_joiner(session_join_string)?;

        let url = if let Some(key) = &self.certificate.remote_signing_key {
            if let Some(env) = &key.session_init.shared_secret_env {
                let secret = std::env::var(env).map_err(|_| AppleCodesignError::CliBadArgument)?;
                joiner
                    .register_state(SessionJoinState::SharedSecret(secret.as_bytes().to_vec()))?;
            } else if let Some(secret) = &key.session_init.shared_secret {
                joiner
                    .register_state(SessionJoinState::SharedSecret(secret.as_bytes().to_vec()))?;
            }

            key.url.clone()
        } else {
            crate::remote_signing::DEFAULT_SERVER_URL.to_string()
        };

        let signing_certs = self.certificate.resolve_certificates(true)?;

        let private = signing_certs.private_key()?;

        let mut public_certificates = signing_certs.certs.clone();
        let cert = public_certificates.remove(0);

        let certificates = if let Some(chain) = cert.apple_root_certificate_chain() {
            // The chain starts with self.
            chain.into_iter().skip(1).collect::<Vec<_>>()
        } else {
            public_certificates
        };

        joiner.register_state(SessionJoinState::PublicKeyDecrypt(
            private.to_public_key_peer_decrypt()?,
        ))?;

        let client = UnjoinedSigningClient::new_signer(
            joiner,
            private.as_key_info_signer(),
            cert,
            certificates,
            url,
        )?;
        client.run()?;

        Ok(())
    }
}

/// Signing arguments that can be scoped.
#[derive(Args, Clone, Debug, Eq, PartialEq)]
pub struct ScopedSigningArgs {
    /// Identifier string for binary. The value normally used by CFBundleIdentifier
    #[arg(long = "binary-identifier", value_name = "IDENTIFIER")]
    binary_identifiers: Vec<String>,

    /// Path to a file containing binary code requirements data to be used as designated requirements
    #[arg(
        long = "code-requirements-file",
        alias = "code-requirements-path",
        value_name = "PATH"
    )]
    code_requirements_paths: Vec<String>,

    /// Path to an XML plist file containing code resources
    #[arg(
        long = "code-resources-file",
        alias = "code-resources",
        value_name = "PATH"
    )]
    code_resources_paths: Vec<String>,

    /// Code signature flags to set
    #[arg(long, value_parser = CodeSignatureFlags::all_user_configurable())]
    code_signature_flags: Vec<String>,

    /// Digest algorithms to use.
    ///
    /// This typically doesn't need to be set since the OS targeting information
    /// from signed binaries implicitly derives appropriate digests to sign with.
    ///
    /// However, there are special cases where you may want to force use of
    /// specific digests.
    ///
    /// The first provided value will become the "primary" digest. Subsequent
    /// values will become alternative digests. The "primary" digest should be
    /// "older" to ensure compatibility with older clients.
    ///
    /// When targeting older Apple OS versions, SHA-1 should be the primary digest
    /// and SHA-256 should also be present for compatibility with newer OS versions.
    ///
    /// When targeting new OS versions, it is sufficient to only provide SHA-256
    /// digests.
    ///
    /// The following values are accepted: none, sha1, sha256, sha384, sha512.
    ///
    /// Important: only "sha1" and "sha256" are widely used and use of other
    /// algorithms may cause problems.
    #[arg(long = "digest", value_name = "DIGEST")]
    digests: Vec<String>,

    /// Path to a plist file containing entitlements
    #[arg(
        short = 'e',
        long = "entitlements-xml-file",
        alias = "entitlements-xml-path",
        value_name = "PATH"
    )]
    entitlements_xml_paths: Vec<String>,

    /// Hardened runtime version to use (defaults to SDK version used to build binary)
    #[arg(long = "runtime-version", value_name = "VERSION")]
    runtime_versions: Vec<String>,

    /// Path to an Info.plist file whose digest to include in Mach-O signature
    #[arg(
        long = "info-plist-file",
        alias = "info-plist-path",
        value_name = "PATH"
    )]
    info_plist_paths: Vec<String>,
}

/// Represents the set of scopable signing settings for a given scope.
#[derive(Clone, Debug, Default, Eq, PartialEq, Deserialize)]
pub struct ScopedSigningSettingsValues {
    pub identifier: Option<String>,
    pub code_requirements_file: Option<PathBuf>,
    pub code_resources_file: Option<PathBuf>,
    pub code_signature_flags: Vec<String>,
    pub digests: Vec<String>,
    pub entitlements_xml_file: Option<PathBuf>,
    pub runtime_version: Option<String>,
    pub info_plist_file: Option<PathBuf>,
}

pub fn split_scoped_value(s: &str) -> (String, &str) {
    let parts = s.splitn(2, ':').collect::<Vec<_>>();

    match parts.len() {
        1 => ("@main".into(), s),
        2 => (parts[0].to_string(), parts[1]),
        _ => {
            panic!("error splitting scoped value; this should not occur");
        }
    }
}

/// A mapping of scopes to collections of signing settings.
///
/// This abstraction exists to make it easier to load config files.
pub struct ScopedSigningSettings(BTreeMap<String, ScopedSigningSettingsValues>);

impl TryFrom<&ScopedSigningArgs> for ScopedSigningSettings {
    type Error = AppleCodesignError;

    fn try_from(args: &ScopedSigningArgs) -> Result<Self, Self::Error> {
        let mut res = BTreeMap::<String, ScopedSigningSettingsValues>::default();

        for value in &args.binary_identifiers {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope).or_default().identifier = Some(value.into());
        }

        for value in &args.code_requirements_paths {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope).or_default().code_requirements_file = Some(value.into());
        }

        for value in &args.code_resources_paths {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope).or_default().code_resources_file = Some(value.into());
        }

        for value in &args.code_signature_flags {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope)
                .or_default()
                .code_signature_flags
                .push(value.into());
        }

        for value in &args.digests {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope).or_default().digests.push(value.into());
        }

        for value in &args.entitlements_xml_paths {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope).or_default().entitlements_xml_file = Some(value.into());
        }

        for value in &args.runtime_versions {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope).or_default().runtime_version = Some(value.into());
        }

        for value in &args.info_plist_paths {
            let (scope, value) = split_scoped_value(value);
            res.entry(scope).or_default().info_plist_file = Some(value.into());
        }

        Ok(Self(res))
    }
}

impl ScopedSigningSettings {
    pub fn load_into_settings(
        self,
        settings: &mut SigningSettings,
    ) -> Result<(), AppleCodesignError> {
        for (scope, values) in self.0 {
            let scope = SettingsScope::try_from(scope.as_str())?;

            if let Some(v) = values.identifier {
                settings.set_binary_identifier(scope.clone(), v);
            }

            if let Some(v) = values.code_requirements_file {
                let code_requirements_data = std::fs::read(v)?;
                let reqs = CodeRequirements::parse_blob(&code_requirements_data)?.0;
                for expr in reqs.iter() {
                    warn!(
                        "setting designated code requirements for {}: {}",
                        scope, expr
                    );

                    settings.set_designated_requirement_expression(scope.clone(), expr)?;
                }
            }

            if let Some(path) = values.code_resources_file {
                warn!(
                    "setting code resources data for {} from path {}",
                    scope,
                    path.display()
                );
                let code_resources_data = std::fs::read(path)?;
                settings.set_code_resources_data(scope.clone(), code_resources_data);
            }

            // If code signature flags are specified, they overwrite defaults. So reset
            // current values on the scope before setting anything.
            if !values.code_signature_flags.is_empty() {
                if let Some(existing) = settings.code_signature_flags(&scope) {
                    if existing != CodeSignatureFlags::empty() {
                        warn!(
                            "removing code signature flags {:?} from {}",
                            existing, scope
                        );
                    }
                }

                settings.set_code_signature_flags(scope.clone(), CodeSignatureFlags::empty());
            }

            for value in values.code_signature_flags {
                let flags = CodeSignatureFlags::from_str(&value)?;
                warn!("adding code signature flag {:?} to {}", flags, scope);
                settings.add_code_signature_flags(scope.clone(), flags);
            }

            for (i, value) in values.digests.into_iter().enumerate() {
                let digest_type = DigestType::try_from(value.as_str())?;

                if i == 0 {
                    settings.set_digest_type(scope.clone(), digest_type);
                } else {
                    settings.add_extra_digest(scope.clone(), digest_type);
                }
            }

            if let Some(path) = values.entitlements_xml_file {
                warn!(
                    "setting entitlements XML for {} from path {}",
                    scope,
                    path.display()
                );
                let entitlements_data = std::fs::read_to_string(path)?;
                settings.set_entitlements_xml(scope.clone(), entitlements_data)?;
            }

            if let Some(value) = values.runtime_version {
                let version = semver::Version::parse(&value)?;
                settings.set_runtime_version(scope.clone(), version);
            }

            if let Some(path) = values.info_plist_file {
                let data = std::fs::read(path)?;
                settings.set_info_plist_data(scope, data);
            }
        }

        Ok(())
    }
}

#[derive(Parser)]
struct Sign {
    #[command(flatten)]
    scoped: ScopedSigningArgs,

    /// Team name/identifier to include in code signature
    #[arg(long, value_name = "NAME")]
    team_name: Option<String>,

    /// An RFC 3339 date and time string to be used in signatures.
    ///
    /// e.g. 2023-11-05T10:42:00Z.
    ///
    /// If not specified, the current time will be used.
    ///
    /// Setting is only used when signing with a signing certificate.
    ///
    /// This setting is typically not necessary. It was added to facilitate
    /// deterministic signing behavior.
    #[arg(long)]
    signing_time: Option<String>,

    /// URL of time-stamp server to use to obtain a token of the CMS signature
    ///
    /// Can be set to the special value `none` to disable the generation of time-stamp
    /// tokens and use of a time-stamp server.
    #[arg(long, default_value = APPLE_TIMESTAMP_URL)]
    timestamp_url: String,

    /// Glob expression of paths to exclude from signing
    #[arg(long)]
    exclude: Vec<String>,

    /// Path to Mach-O binary to sign
    input_path: PathBuf,

    /// Path to signed Mach-O binary to write
    output_path: Option<PathBuf>,

    #[command(flatten)]
    certificate: CertificateSource,
}

impl Sign {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let mut settings = SigningSettings::default();

        let certs = self.certificate.resolve_certificates(true)?;
        certs.load_into_signing_settings(&mut settings)?;

        // Doesn't make sense to set a time-stamp server URL unless we're generating
        // CMS signatures.
        if settings.signing_key().is_some() && self.timestamp_url != "none" {
            warn!("using time-stamp protocol server {}", self.timestamp_url);
            settings.set_time_stamp_url(&self.timestamp_url)?;
        }

        if let Some(time) = &self.signing_time {
            let time = chrono::DateTime::parse_from_rfc3339(time).map_err(|e| {
                AppleCodesignError::CliGeneralError(format!("invalid signing time format: {}", e))
            })?;
            let time = time.with_timezone(&chrono::Utc);
            settings.set_signing_time(time);
        }

        if let Some(team_id) = settings.set_team_id_from_signing_certificate() {
            warn!(
                "automatically setting team ID from signing certificate: {}",
                team_id
            );
        }

        if let Some(team_name) = &self.team_name {
            settings.set_team_id(team_name);
        }

        for pattern in &self.exclude {
            settings.add_path_exclusion(pattern)?;
        }

        ScopedSigningSettings::try_from(&self.scoped)?.load_into_settings(&mut settings)?;

        // Settings are locked in. Proceed to sign.

        let signer = UnifiedSigner::new(settings);

        if let Some(output_path) = &self.output_path {
            warn!(
                "signing {} to {}",
                self.input_path.display(),
                output_path.display()
            );
            signer.sign_path(&self.input_path, output_path)?;
        } else {
            warn!("signing {} in place", self.input_path.display());
            signer.sign_path_in_place(&self.input_path)?;
        }

        if let Some(private) = certs.private_key_optional()? {
            private.finish()?;
        }

        Ok(())
    }
}

#[derive(Parser)]
struct SmartcardScan {}

impl SmartcardScan {
    #[cfg(feature = "yubikey")]
    fn run(&self) -> Result<(), AppleCodesignError> {
        let mut ctx = ::yubikey::reader::Context::open()?;
        for (index, reader) in ctx.iter()?.enumerate() {
            println!("Device {}: {}", index, reader.name());

            if let Ok(yk) = reader.open() {
                let mut yk = crate::yubikey::YubiKey::from(yk);
                println!("Device {}: Serial: {}", index, yk.inner()?.serial());
                println!("Device {}: Version: {}", index, yk.inner()?.version());

                for (slot, cert) in yk.find_certificates()? {
                    println!(
                        "Device {}: Certificate in slot {:?} / {}",
                        index,
                        slot,
                        hex::encode([u8::from(slot)])
                    );
                    print_certificate_info(&cert)?;
                    println!();
                }
            }
        }

        Ok(())
    }

    #[cfg(not(feature = "yubikey"))]
    fn run(&self) -> Result<(), AppleCodesignError> {
        eprintln!("smartcard reading requires the `yubikey` crate feature, which isn't enabled.");
        eprintln!("recompile the crate with `cargo build --features yubikey` to enable support");
        std::process::exit(1);
    }
}

#[derive(Parser)]
struct SmartcardGenerateKey {
    /// Smartcard slot number to store key in (9c is common)
    #[arg(long)]
    smartcard_slot: String,

    #[command(flatten)]
    policy: YubikeyPolicy,
}

impl SmartcardGenerateKey {
    #[cfg(feature = "yubikey")]
    fn run(&self) -> Result<(), AppleCodesignError> {
        let slot_id = ::yubikey::piv::SlotId::from_str(&self.smartcard_slot)?;

        let touch_policy = str_to_touch_policy(self.policy.touch_policy.as_str())?;
        let pin_policy = str_to_pin_policy(self.policy.pin_policy.as_str())?;

        let mut yk = YubiKey::new()?;
        yk.set_pin_callback(prompt_smartcard_pin);

        yk.generate_key(slot_id, touch_policy, pin_policy)?;

        Ok(())
    }

    #[cfg(not(feature = "yubikey"))]
    fn run(&self) -> Result<(), AppleCodesignError> {
        eprintln!(
            "smartcard integration requires the `yubikey` crate feature, which isn't enabled."
        );
        eprintln!("recompile the crate with `cargo build --features yubikey` to enable support");
        std::process::exit(1);
    }
}

#[derive(Parser)]
struct SmartcardImport {
    /// Re-use the existing private key in the smartcard slot
    #[arg(long)]
    existing_key: bool,

    /// Don't actually perform the import
    #[arg(long)]
    dry_run: bool,

    #[command(flatten)]
    certificate: CertificateSource,

    #[command(flatten)]
    policy: YubikeyPolicy,
}

impl SmartcardImport {
    #[cfg(feature = "yubikey")]
    fn run(&self) -> Result<(), AppleCodesignError> {
        let signing_certs = self.certificate.resolve_certificates(false)?;

        let slot_id = ::yubikey::piv::SlotId::from_str(
            self.certificate
                .smartcard_key
                .as_ref()
                .unwrap()
                .slot
                .as_ref()
                .ok_or_else(|| {
                    error!("--smartcard-slot is required");
                    AppleCodesignError::CliBadArgument
                })?,
        )?;
        let touch_policy = str_to_touch_policy(self.policy.touch_policy.as_str())?;
        let pin_policy = str_to_pin_policy(self.policy.pin_policy.as_str())?;

        println!(
            "found {} private keys and {} public certificates",
            signing_certs.keys.len(),
            signing_certs.certs.len()
        );

        let key = if self.existing_key {
            println!("using existing private key in smartcard");

            if !signing_certs.keys.is_empty() {
                println!(
                    "ignoring {} private keys specified via arguments",
                    signing_certs.keys.len()
                );
            }

            None
        } else {
            Some(signing_certs.private_key()?)
        };

        let cert = signing_certs
            .certs
            .clone()
            .into_iter()
            .next()
            .ok_or_else(|| {
                println!("no public certificates found");
                AppleCodesignError::CliBadArgument
            })?;

        println!(
            "Will import the following certificate into slot {}",
            hex::encode([u8::from(slot_id)])
        );
        print_certificate_info(&cert)?;

        let mut yk = YubiKey::new()?;
        yk.set_pin_callback(prompt_smartcard_pin);

        if self.dry_run {
            println!("dry run mode enabled; stopping");
            return Ok(());
        }

        if let Some(key) = key {
            yk.import_key(
                slot_id,
                key.as_key_info_signer(),
                &cert,
                touch_policy,
                pin_policy,
            )?;
        } else {
            yk.import_certificate(slot_id, &cert)?;
        }

        Ok(())
    }

    #[cfg(not(feature = "yubikey"))]
    fn run(&self) -> Result<(), AppleCodesignError> {
        eprintln!("smartcard import requires `yubikey` crate feature, which isn't enabled.");
        eprintln!("recompile the crate with `cargo build --features yubikey` to enable support");
        std::process::exit(1);
    }
}

#[derive(Parser)]
struct Staple {
    /// Path to entity to attempt to staple
    path: PathBuf,
}

impl Staple {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let stapler = crate::stapling::Stapler::new()?;
        stapler.staple_path(&self.path)?;

        Ok(())
    }
}

#[derive(Parser)]
struct Verify {
    /// Path of Mach-O binary to examine
    path: PathBuf,
}

impl Verify {
    fn run(&self) -> Result<(), AppleCodesignError> {
        let path_type = crate::PathType::from_path(&self.path)?;

        if path_type != crate::PathType::MachO {
            return Err(AppleCodesignError::CliGeneralError(format!(
                "verify command only works on Mach-O binaries; provided path is a {:?}",
                path_type
            )));
        }

        warn!("(the verify command is known to be buggy and gives misleading results; we highly recommend using Apple's tooling until this message is removed)");
        let data = std::fs::read(&self.path)?;

        let problems = crate::verify::verify_macho_data(data);

        for problem in &problems {
            println!("{problem}");
        }

        if problems.is_empty() {
            eprintln!("no problems detected!");
            eprintln!("(we do not verify everything so please do not assume that the signature meets Apple standards)");
            Ok(())
        } else {
            Err(AppleCodesignError::VerificationProblems)
        }
    }
}

#[derive(Parser)]
struct X509Oids {}

impl X509Oids {
    fn run(&self) -> Result<(), AppleCodesignError> {
        println!("# Extended Key Usage (EKU) Extension OIDs");
        println!();
        for ekup in crate::certificate::ExtendedKeyUsagePurpose::all() {
            println!("{}\t{:?}", ekup.as_oid(), ekup);
        }
        println!();
        println!("# Code Signing Certificate Extension OIDs");
        println!();
        for ext in crate::certificate::CodeSigningCertificateExtension::all() {
            println!("{}\t{:?}", ext.as_oid(), ext);
        }
        println!();
        println!("# Certificate Authority Certificate Extension OIDs");
        println!();
        for ext in crate::certificate::CertificateAuthorityExtension::all() {
            println!("{}\t{:?}", ext.as_oid(), ext);
        }

        Ok(())
    }
}

#[derive(Subcommand)]
#[allow(clippy::large_enum_variant)]
enum Subcommands {
    /// Analyze an X.509 certificate for Apple code signing properties.
    ///
    /// Given the path to a PEM encoded X.509 certificate, this command will read
    /// the certificate and print information about it relevant to Apple code
    /// signing.
    ///
    /// The output of the command can be useful to learn about X.509 certificate
    /// extensions used by code signing certificates and to debug low-level
    /// properties related to certificates.
    AnalyzeCertificate(AnalyzeCertificate),

    /// Compute code hashes for a binary
    ComputeCodeHashes(ComputeCodeHashes),

    /// Create a binary code requirements file.
    #[command(hide = true)]
    DebugCreateCodeRequirements(debug_commands::DebugCreateCodeRequirements),

    /// Create an entitlements file.
    #[command(hide = true)]
    DebugCreateEntitlements(debug_commands::DebugCreateEntitlements),

    /// Create an Info.plist file.
    #[command(hide = true)]
    DebugCreateInfoPlist(debug_commands::DebugCreateInfoPlist),

    /// Create a Mach-O binary from parameters.
    #[command(hide = true)]
    DebugCreateMacho(debug_commands::DebugCreateMachO),

    /// Print a filesystem tree with basic metadata.
    #[command(hide = true)]
    DebugFileTree(debug_commands::DebugFileTree),

    /// Print a diff between the signature content of two paths
    DiffSignatures(DiffSignatures),

    /// Encode App Store Connect API Key metadata to a single file
    #[cfg(feature = "notarize")]
    #[command(long_about = ENCODE_APP_STORE_CONNECT_API_KEY_ABOUT)]
    EncodeAppStoreConnectApiKey(EncodeAppStoreConnectApiKey),

    /// Print/extract various information from a Mach-O binary.
    ///
    /// Given the path to a Mach-O binary (including fat/universal binaries), this
    /// command will attempt to locate and format the requested data.
    #[command(override_usage = "rcodesign extract [OPTIONS] <COMMAND> <INPUT_PATH>")]
    Extract(Extract),

    /// Generates a certificate signing request that can be sent to Apple and exchanged for a signing certificate
    GenerateCertificateSigningRequest(GenerateCertificateSigningRequest),

    /// Generate a self-signed certificate for code signing
    #[command(long_about = GENERATE_SELF_SIGNED_CERTIFICATE_ABOUT)]
    GenerateSelfSignedCertificate(GenerateSelfSignedCertificate),

    /// Export Apple CA certificates from the macOS Keychain
    KeychainExportCertificateChain(KeychainExportCertificateChain),

    /// Print information about certificates in the macOS keychain
    KeychainPrintCertificates(KeychainPrintCertificates),

    /// Create a universal ("fat") Mach-O binary.
    ///
    /// This is similar to the `lipo -create` command. Use it to stitch
    /// multiple single architecture Mach-O binaries into a single multi-arch
    /// binary.
    MachoUniversalCreate(MachoUniversalCreate),

    #[cfg(feature = "notarize")]
    /// Fetch the notarization log for a previous submission
    NotaryLog(NotaryLog),

    /// Upload an asset to Apple for notarization and possibly staple it
    #[cfg(feature = "notarize")]
    #[command(long_about = NOTARIZE_ABOUT, alias = "notarize")]
    NotarySubmit(NotarySubmit),

    /// Wait for completion of a previous submission
    #[cfg(feature = "notarize")]
    NotaryWait(NotaryWait),

    /// Parse binary Code Signing Requirement data into a human readable string
    #[command(long_about = PARSE_CODE_SIGNING_REQUIREMENT_ABOUT)]
    ParseCodeSigningRequirement(ParseCodeSigningRequirement),

    /// Print signature information for a filesystem path
    PrintSignatureInfo(PrintSignatureInfo),

    /// Create signatures initiated from a remote signing operation
    RemoteSign(RemoteSign),

    /// Sign a Mach-O binary or bundle
    #[command(long_about = SIGN_ABOUT)]
    Sign(Sign),

    /// Generate a new private key on a smartcard
    SmartcardGenerateKey(SmartcardGenerateKey),

    /// Import a code signing certificate and key into a smartcard
    SmartcardImport(SmartcardImport),

    /// Show information about available smartcard (SC) devices
    SmartcardScan(SmartcardScan),

    /// Staples a notarization ticket to an entity
    Staple(Staple),

    /// Verifies code signature data
    Verify(Verify),

    /// Print information about X.509 OIDs related to Apple code signing
    X509Oids(X509Oids),
}

/// Sign and notarize Apple programs. See https://gregoryszorc.com/docs/apple-codesign/main/ for more docs
#[derive(Parser)]
#[command(author, version, arg_required_else_help = true)]
struct Cli {
    /// Increase logging verbosity. Can be specified multiple times
    #[arg(short = 'v', long, global = true, action = ArgAction::Count)]
    verbose: u8,

    #[command(subcommand)]
    command: Subcommands,
}

pub fn main_impl() -> Result<(), AppleCodesignError> {
    let cli = Cli::parse();

    let log_level = match cli.verbose {
        0 => LevelFilter::Warn,
        1 => LevelFilter::Info,
        2 => LevelFilter::Debug,
        _ => LevelFilter::Trace,
    };

    let mut builder = env_logger::Builder::from_env(
        env_logger::Env::default().default_filter_or(log_level.as_str()),
    );

    // Disable log context except at higher log levels.
    if log_level <= LevelFilter::Info {
        builder
            .format_timestamp(None)
            .format_level(false)
            .format_target(false);
    }

    // This spews unwanted output at default level. Nerf it by default.
    if log_level == LevelFilter::Info {
        builder.filter_module("rustls", LevelFilter::Error);
    }

    builder.init();

    match &cli.command {
        Subcommands::AnalyzeCertificate(args) => args.run(),
        Subcommands::ComputeCodeHashes(args) => args.run(),
        Subcommands::DiffSignatures(args) => args.run(),
        #[cfg(feature = "notarize")]
        Subcommands::EncodeAppStoreConnectApiKey(args) => args.run(),
        Subcommands::DebugCreateCodeRequirements(args) => args.run(),
        Subcommands::DebugCreateEntitlements(args) => args.run(),
        Subcommands::DebugCreateInfoPlist(args) => args.run(),
        Subcommands::DebugCreateMacho(args) => args.run(),
        Subcommands::DebugFileTree(args) => args.run(),
        Subcommands::Extract(args) => args.run(),
        Subcommands::GenerateCertificateSigningRequest(args) => args.run(),
        Subcommands::GenerateSelfSignedCertificate(args) => args.run(),
        Subcommands::KeychainExportCertificateChain(args) => args.run(),
        Subcommands::KeychainPrintCertificates(args) => args.run(),
        Subcommands::MachoUniversalCreate(args) => args.run(),
        #[cfg(feature = "notarize")]
        Subcommands::NotaryLog(args) => args.run(),
        #[cfg(feature = "notarize")]
        Subcommands::NotarySubmit(args) => args.run(),
        #[cfg(feature = "notarize")]
        Subcommands::NotaryWait(args) => args.run(),
        Subcommands::ParseCodeSigningRequirement(args) => args.run(),
        Subcommands::PrintSignatureInfo(args) => args.run(),
        Subcommands::RemoteSign(args) => args.run(),
        Subcommands::Sign(args) => args.run(),
        Subcommands::SmartcardGenerateKey(args) => args.run(),
        Subcommands::SmartcardImport(args) => args.run(),
        Subcommands::SmartcardScan(args) => args.run(),
        Subcommands::Staple(args) => args.run(),
        Subcommands::Verify(args) => args.run(),
        Subcommands::X509Oids(args) => args.run(),
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use clap::CommandFactory;

    #[test]
    fn verify_cli() {
        Cli::command().debug_assert();
    }
}
